diff --git a/include/znc/znc.h b/include/znc/znc.h
index 08d12f3..b5f2e97 100644
--- a/include/znc/znc.h
+++ b/include/znc/znc.h
@@ -185,6 +185,8 @@ public:
 
 	static void DumpConfig(const CConfig* Config);
 
+	void SetSystemWideConfig(bool systemWideConfig);
+
 private:
 	CFile* InitPidFile();
 	bool DoRehash(CString& sError);
@@ -229,6 +231,7 @@ protected:
 	unsigned int           m_uiConnectPaused;
 	TCacheMap<CString>     m_sConnectThrottle;
 	bool                   m_bProtectWebSessions;
+	bool                   m_bSystemWideConfig;
 };
 
 #endif // !_ZNC_H
diff --git a/src/main.cpp b/src/main.cpp
index 844c8a3..4bd2504 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -16,6 +16,9 @@
 
 #include <znc/znc.h>
 #include <signal.h>
+#include <sys/types.h>
+#include <pwd.h>
+#include <grp.h>
 
 #if defined(HAVE_LIBSSL) && defined(HAVE_PTHREAD)
 #include <znc/Threads.h>
@@ -109,6 +112,7 @@ static const struct option g_LongOpts[] = {
 	{ "makepass",    no_argument,       0, 's' },
 	{ "makepem",     no_argument,       0, 'p' },
 	{ "datadir",     required_argument, 0, 'd' },
+	{ "system-wide-config-as",      required_argument, 0, 'S' },
 	{ 0, 0, 0, 0 }
 };
 
@@ -192,6 +196,8 @@ int main(int argc, char** argv) {
 	bool bMakeConf = false;
 	bool bMakePass = false;
 	bool bAllowRoot = false;
+	bool bSystemWideConfig = false;
+	CString sSystemWideConfigUser = "znc";
 	bool bForeground = false;
 #ifdef ALWAYS_RUN_IN_FOREGROUND
 	bForeground = true;
@@ -200,7 +206,7 @@ int main(int argc, char** argv) {
 	bool bMakePem = false;
 #endif
 
-	while ((iArg = getopt_long(argc, argv, "hvnrcspd:Df", g_LongOpts, &iOptIndex)) != -1) {
+	while ((iArg = getopt_long(argc, argv, "hvnrcspd:DfS", g_LongOpts, &iOptIndex)) != -1) {
 		switch (iArg) {
 		case 'h':
 			GenerateHelp(argv[0]);
@@ -218,6 +224,10 @@ int main(int argc, char** argv) {
 		case 'c':
 			bMakeConf = true;
 			break;
+		case 'S':
+			bSystemWideConfig = true;
+			sSystemWideConfigUser = optarg;
+			break;
 		case 's':
 			bMakePass = true;
 			break;
@@ -252,10 +262,38 @@ int main(int argc, char** argv) {
 		return 1;
 	}
 
+	if (bSystemWideConfig && getuid() == 0) {
+		struct passwd *pwd;
+
+		pwd = getpwnam(sSystemWideConfigUser.c_str());
+		if (pwd == NULL) {
+			CUtils::PrintError("Daemon user not found.");
+			return 1;
+		}
+
+		if ((long) pwd->pw_uid == 0) {
+			CUtils::PrintError("Please define a daemon user other than root.");
+			return 1;
+		}
+		if (setgroups(0, NULL) != 0) {
+			CUtils::PrintError("setgroups: Unable to clear supplementary group IDs");
+			return 1;
+		}
+		if (setgid((long) pwd->pw_gid) != 0) {
+			CUtils::PrintError("setgid: Unable to drop group privileges");
+			return 1;
+		}
+		if (setuid((long) pwd->pw_uid) != 0) {
+			CUtils::PrintError("setuid: Unable to drop user privileges");
+			return 1;
+		}
+	}
+
 	CZNC::CreateInstance();
 
 	CZNC* pZNC = &CZNC::Get();
 	pZNC->InitDirs(((argc) ? argv[0] : ""), sDataDir);
+	pZNC->SetSystemWideConfig(bSystemWideConfig);
 
 #ifdef HAVE_LIBSSL
 	if (bMakePem) {
@@ -304,7 +342,7 @@ int main(int argc, char** argv) {
 		CUtils::PrintStatus(true, "");
 	}
 
-	if (isRoot()) {
+	if (isRoot() && !bSystemWideConfig) {
 		CUtils::PrintError("You are running ZNC as root! Don't do that! There are not many valid");
 		CUtils::PrintError("reasons for this and it can, in theory, cause great damage!");
 		if (!bAllowRoot) {
diff --git a/src/znc.cpp b/src/znc.cpp
index e2c8c5b..55c3289 100644
--- a/src/znc.cpp
+++ b/src/znc.cpp
@@ -55,6 +55,7 @@ CZNC::CZNC() {
 	m_sConnectThrottle.SetTTL(30000);
 	m_pLockFile = NULL;
 	m_bProtectWebSessions = true;
+	m_bSystemWideConfig = false;
 	m_uDisabledSSLProtocols = Csock::EDP_SSL;
 	m_sSSLProtocols = "";
 }
@@ -856,7 +857,7 @@ bool CZNC::WriteNewConfig(const CString& sConfigFile) {
 	CUtils::PrintMessage("");
 
 	File.UnLock();
-	return bFileOpen && CUtils::GetBoolInput("Launch ZNC now?", true);
+	return bFileOpen && !m_bSystemWideConfig && CUtils::GetBoolInput("Launch ZNC now?", true);
 }
 
 void CZNC::BackupConfigOnce(const CString& sSuffix) {
@@ -1966,3 +1967,7 @@ void CZNC::LeakConnectQueueTimer(CConnectQueueTimer *pTimer) {
 bool CZNC::WaitForChildLock() {
 	return m_pLockFile && m_pLockFile->ExLock();
 }
+
+void CZNC::SetSystemWideConfig(bool systemWideConfig) {
+	m_bSystemWideConfig = systemWideConfig;
+}
